'''
소수 구하기 문제
숫자 m과 n이 주어질때 두 수 사이에 있는 소수를 모두 출력하는 프로그램을 작성하시오.
'''

m,n = map(int, input().split())
unique = set()
unique.add(2)

for i in range(3, n+1):
    is_unique = True 
    for u in unique:
        if i % u == 0: #소수로 나누어진다면
            is_unique = False
            break
    if is_unique:
        unique.add(i)
    if is_unique and i >= m:
        print(i)

'''
시간초과 문제 해결하는 방법
소수를 구하는데 전부 다 탐색하기에는 시간이 너무 오래걸린다. 
이때 에라토스테네스의 체 라는 소수를 빠르게 구하는 알고리즘이 존재한다
이 알고리즘의 기본 아이디어는 2부터 시작하여 소수인 수의 배수를 모두 제거하는 것이다. 그럼 자동으로 나머지 숫자들 중 소수만 남게된다.
이것도 공간을 이용해서 시간복잡도를 줄이는 방법을 활용해야 한다.
지금부터 내가 이해한 에라토스테네스의 체 알고리즘을 작성할 것이니, 다음번에 이를 보고 다시 코드를 작성해봐라

1. 공간으로 시간복잡도를 해결하는 방법 첫 번째는 리스트를 활용해서 각 숫자가 소수인지, 소수가 아닌지를 직접 저장하는 것이다.
이때 0,1 을 활용하는 것 보다 true false 를 활용하는 것이 비트 수를 아낄 수 있을 것이라고 판단된다.
2. 2는 소수이지만, 2의 배수는 전부 소수가 아니다. 따라서 2를 진행하면서 첫 번째 것만 제외하고 다음 배수인 부분은(배수는 같은 수를 계속 더하는 것으로)
전부 false로 처리할 수 있다. 
3. 2,3,4 순으로 늘려나가는데, 4의 배수중 4*1, 4*2, 4*3 등은 이미 앞에서 같은 곱하기지만 순서만 바꾸어서 실행했다. 따라서 p*p 부터 실행하면
그 다음 것 부터 진행 할 수 있을 것이라고 생각된다. 
4. 나의 생각 --> 만약 p에 대해서도 앞에서 구한 소수를 저장한다면, p의 배수를 신경쓰지 않아도 될까? --> 이 경우 뒤에서 나온 새로운 소수에 대해서 p*p
부터 시작할 수 없는 문제가 생긴다. p가 7 이라면 7*7 부터 시작해야하는데, 이때 6*7 같은 경우는 제거가 안될 수도.. 근데 이 경우 2의 배수에서 걸러지지 않나?
시도해볼 가치는 있을 듯 하다. 1,2,3을 구현한 다음 4를 추가하는 방법을 생각해 봐라.
'''