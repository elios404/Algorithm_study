'''
등수 구하기 문제
입력으로 몇개의 점수가 리스트에 주어질 것인지, 새로운 점수, 몇 개까지 등수를 매길 것인지 이다.
주어진 리스트는 내림차순으로 되어있기에 딱히 새롭게 정렬을 할 필요가 없다. 따라서 새로운 점수를 크기에 맞는 위치 중 가장 마지막에 넣고
인덱스를 p 입력 받는 곳 까지 체크하면 된다. 이때 추가로 앞에 있는 점수가 내 점수와 같은지 체크하고 같을 경우 앞쪽 인덱스의 값을 등수로 출력하면 된다.
'''

'''
이진탐색으로 입력이 많아 질 때 빠르게 구할 수 있게 하려고 시도를 함. 그러나 정확하게 알고리즘을 짜는 데 어려움을 겪음
그렇다면 이진 탐색으로 어느 정도 까지 구한 다음에 들어갈 위치를 정확하게 탐색해야 할까?
새로운 점수보다 작은 부분의 인덱스를 찾고, 그것보다 바로 앞으로 가도록 하면 되지 않을까?
양쪽보다 크거나 작은 경우는 계산할 필요가 없다. 
'''

'''
일단은 그냥 전체 탐색으로 진행하는 것으로 해 보자. --> 어딘가에서 잘못된 출력이 생김
가장 처음 위치에 들어가는 경우의 수를 if 문을 통해서 추가 --> 오답
62% 정도에서 계속 오답이 발생, 특정한 경우의 수를 놓치고 있는 것이라고 생각된다.
'''

'''
나중에 다시 풀어보기 --> gpt의 해답
랭크를 구하는 것과 같은 점수에 대해서 같은 등수를 매기는 경우
특정 점수에 대해서 1등을 주고 다른 것과 비교해서 작을 경우 등수를 하나씩 깎아가는 방식으로 진행을 한다.
'''


n, new_score, p = map(int, input().split())

if n == 0:
    print("1")
else:
    score_list = list(map(int,input().split()))
    #print("input complete")

    target_index = n

    for i in range(n): #들어갈 위치를 탐색, 근데 끝까지 가야하는 상황이라면? --> 이 경우 가장 처음에 들어가는 경우를 구할 수가 없다.
        if score_list[n-1-i] >= new_score: #끝에서 부터 탐색하면서 새로운 점수보다 크거나 같은 인덱스의 다음 인덱스가 새로운 점수의 인덱스
            break
        else:
            target_index -= 1 #앞에 있는 수가 자기보다 크거나 같지 않다면, 한 칸 앞으로 이동

    #print("found target_index", target_index)
    
    rank = target_index+1 #랭크는 1부터 시작하기에
    for i in range(1,n):
        if rank == 1: #가장 앞에있는 경우 중복을 체크할 필요가 없음
            break
        elif score_list[target_index-i] == new_score: #2번쨰 부터 자기 앞에 있는 것이 자기와 같은지 확인
            rank -= 1
        else: #자기 앞이 자신과 같지 않으면 바로 중지
            break
    
    #print("found rank = ", rank)

    if target_index+1 > p: #인덱스의 위치가 표시가능 수보다 큰 경우
        print("-1")
    else:
        print(rank) #rank starts from 1
