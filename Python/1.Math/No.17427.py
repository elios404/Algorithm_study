'''
약수의 합 2
문제의 시간제한은 촉박하고 메모리 제한은 널널한 것을 보니, 메모리를 사용하여 시간을 줄이는 방법을 사용해야 풀 수 있을 듯 하다.
자연수 n이 주어졌을때 n 보다 작은 모든 자연수 들에 대해서 약수의 합들의 합을 구해야 한다.
단순하게 생각하면, n보다 작은 모든 자연수의 약수를 구해야 하고, 이것의 합을 구한 다음, 다시 전부 합하면 된다.

약수를 구하는 것은 배수를 구하는 것과 비슷하다고 생각된다. 그렇다면 n까지의 수 중 소수를 구한 다음,
각각의 소수가 n까지 몇개의 배수를 가지는 지를 구한 다음 --> n / 소수, 소수  * 개수를 한 것을 더하면 될 듯 하다
소수는 직접 구해야 하는 것으로 알고 있다.

수는 소수와 소수가 아닌 수로 나누어 지는데, 소수가 아닌 수는 소수로 나누었을 때 나머지가 0이 된다.

2024.09.13일 11시 10분 시작, 12시 까지만 고민해보자

일단 소수를 구하는 방식으로 코드를 작성해보자
접근이 잘못되었다. 소수를 구하고 소수가 등장하는 수만 큼 더한다는 것은 약수중에 소수끼리 곱해지는 것을 포함하지 못한다.

아주 기본적으로 생각한다면, a까지 1씩 늘려가면서 특정수 n에 대해서 다시 1부터 n까지 늘려가면서 나누어떨어지는 약수를 찾는다
그리고 약수를 찾을 때 마다 정답에 더해준다. 이는 O(n^2)의 시간복잡도를 가진다. 중첩 반복문이기에 

2024.09.13일 11시 31분, 정답이 떠오르지 않음 gpt를 통해서 힌트를 받음
힌트 : 약수의 특징을 생각해 보라, 어떤 특정 수 i는 약수로 여러번 등장한다. 그럼 이때 i 가 몇번 등장하는 지를 구하면 된다.
a까지 특정수의 배수가 몇개 있는 지를 확인하면 된다. i의 배수가 몇 개인지를 확인하면 된다. 
배수의. 갯수를 확인하는 방법은 몫이다.
'''

a  = int(input())

answer = 0
for i in range(1,a+1): 
    answer += i*(a//i) #a까지 i의 배수가 몇개 있는지, 그리고 더해야 하니 i * 갯수 만큼 더한다.

print(answer)
